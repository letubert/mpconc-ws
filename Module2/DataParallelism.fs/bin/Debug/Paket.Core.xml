<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Paket.Core</name></assembly>
<members>
<member name="M:FSharp.Polyfill.AsyncExtensions.Async.Parallel.Static``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``1})">
<summary>
 Runs both computations in parallel and returns the result as a tuple.
</summary>
</member>
<member name="T:FSharp.Polyfill.AsyncExtensions">
<summary>
 Extensions for async workflows.
</summary>
</member>
<member name="T:Fake.Globbing">
<summary>
 This module contains a file pattern globbing implementation.
</summary>
</member>
<member name="P:Paket.AnalyzerLib.Language">
<summary>
 Target language for the analyzer
</summary>
</member>
<member name="P:Paket.AnalyzerLib.Path">
<summary>
 Path of the analyzer dll
</summary>
</member>
<member name="T:Paket.CompileItem">
<summary>
 Compile items inside of project files.
</summary>
</member>
<member name="P:Paket.Dependencies.RootPath">
<summary>
 Get the root path
</summary>
</member>
<member name="P:Paket.Dependencies.RootDirectory">
<summary>
 Get the root directory
</summary>
</member>
<member name="P:Paket.Dependencies.DependenciesFile">
<summary>
 Get path to dependencies file
</summary>
</member>
<member name="M:Paket.Dependencies.UpdatePackage(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,Microsoft.FSharp.Core.FSharpOption{System.String},System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,Paket.SemVerUpdateMode,System.Boolean)">
<summary>
 Updates the given package.
</summary>
</member>
<member name="M:Paket.Dependencies.UpdatePackage(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,Microsoft.FSharp.Core.FSharpOption{System.String},System.Boolean,Paket.SemVerUpdateMode,System.Boolean)">
<summary>
 Updates the given package.
</summary>
</member>
<member name="M:Paket.Dependencies.UpdateGroup(System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,Paket.SemVerUpdateMode,System.Boolean)">
<summary>
 Updates dependencies in single group.
</summary>
</member>
<member name="M:Paket.Dependencies.UpdateFilteredPackages(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,Microsoft.FSharp.Core.FSharpOption{System.String},System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,Paket.SemVerUpdateMode,System.Boolean)">
<summary>
 Update a filtered set of packages
</summary>
</member>
<member name="M:Paket.Dependencies.Update(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,Paket.SemVerUpdateMode,System.Boolean)">
<summary>
 Updates all dependencies.
</summary>
</member>
<member name="M:Paket.Dependencies.Update(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
<summary>
 Updates all dependencies.
</summary>
</member>
<member name="M:Paket.Dependencies.Update(System.Boolean)">
<summary>
 Updates all dependencies.
</summary>
</member>
<member name="M:Paket.Dependencies.TurnOnAutoRestore">
<summary>
 Pulls new paket.targets and bootstrapper and puts them into .paket folder.
</summary>
</member>
<member name="M:Paket.Dependencies.TurnOffAutoRestore">
<summary>
 Removes paket.targets file and Import section from project files.
</summary>
</member>
<member name="M:Paket.Dependencies.Simplify(System.Boolean)">
<summary>
 Converts the current package dependency graph to the simplest dependency graph.
</summary>
</member>
<member name="M:Paket.Dependencies.ShowReferencesFor(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,System.String}})">
<summary>
 Shows all references files where the given package is referenced.
</summary>
</member>
<member name="M:Paket.Dependencies.ShowOutdated(System.Boolean,System.Boolean)">
<summary>
 Lists outdated packages.
</summary>
</member>
<member name="M:Paket.Dependencies.Restore(System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.String},System.Boolean,System.Boolean,System.Boolean)">
<summary>
 Restores packages for all available paket.references files
 (or all packages if onlyReferenced is false)
</summary>
</member>
<member name="M:Paket.Dependencies.Restore(System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Collections.FSharpList{System.String},System.Boolean,System.Boolean)">
<summary>
 Restores the given paket.references files.
</summary>
</member>
<member name="M:Paket.Dependencies.Restore(Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Restores the given paket.references files.
</summary>
</member>
<member name="M:Paket.Dependencies.Restore(Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Collections.FSharpList{System.String},System.Boolean)">
<summary>
 Restores the given paket.references files.
</summary>
</member>
<member name="M:Paket.Dependencies.Restore">
<summary>
 Restores all dependencies.
</summary>
</member>
<member name="M:Paket.Dependencies.Restore(System.Boolean)">
<summary>
 Restores all dependencies.
</summary>
</member>
<member name="M:Paket.Dependencies.RemoveFromProject(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,System.Boolean,System.String,System.Boolean)">
<summary>
 Removes the given package from the specified project
</summary>
</member>
<member name="M:Paket.Dependencies.Remove(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,System.Boolean,System.Boolean,System.Boolean)">
<summary>
 Removes the given package from dependencies file.
</summary>
</member>
<member name="M:Paket.Dependencies.Remove(Microsoft.FSharp.Core.FSharpOption{System.String},System.String)">
<summary>
 Removes the given package from dependencies file.
</summary>
</member>
<member name="M:Paket.Dependencies.Remove(System.String)">
<summary>
 Removes the given package from the main dependency group of the dependencies file.
</summary>
</member>
<member name="M:Paket.Dependencies.Push(System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Pushes a nupkg file.
</summary>
</member>
<member name="M:Paket.Dependencies.Process``1(Microsoft.FSharp.Core.FSharpFunc{Paket.PaketEnv,Chessie.ErrorHandling.Result{``0,Paket.Domain.DomainMessage}})">
<summary>
 Binds the given processing ROP function to current environment and executes it.
 Throws on failure.
</summary>
</member>
<member name="M:Paket.Dependencies.Locate(System.String)">
<summary>
 Tries to locate the paket.dependencies file in the given folder or a parent folder.
</summary>
</member>
<member name="M:Paket.Dependencies.Locate">
<summary>
 Tries to locate the paket.dependencies file in the current folder or a parent folder.
</summary>
</member>
<member name="M:Paket.Dependencies.ListTemplateFiles">
<summary>
 Lists all paket.template files in the current solution.
</summary>
</member>
<member name="M:Paket.Dependencies.Install(System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Paket.SemVerUpdateMode},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Creates a paket.dependencies file with the given text in the current directory and installs it.
</summary>
</member>
<member name="M:Paket.Dependencies.Install(Paket.InstallerOptions)">
<summary>
 Installs all dependencies.
</summary>
</member>
<member name="M:Paket.Dependencies.Install(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,Paket.SemVerUpdateMode,System.Boolean)">
<summary>
 Installs all dependencies.
</summary>
</member>
<member name="M:Paket.Dependencies.Install(System.Boolean)">
<summary>
 Installs all dependencies.
</summary>
</member>
<member name="M:Paket.Dependencies.Init(System.String)">
<summary>
 Initialize paket.dependencies file in the given directory
</summary>
</member>
<member name="M:Paket.Dependencies.Init">
<summary>
 Initialize paket.dependencies file in current directory
</summary>
</member>
<member name="M:Paket.Dependencies.GetSources">
<summary>
 Returns all sources from the dependencies file.
</summary>
</member>
<member name="M:Paket.Dependencies.GetLockFile">
<summary>
 Returns an instance of the paket.lock file.
</summary>
</member>
<member name="M:Paket.Dependencies.GetLibraries(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,Paket.FrameworkIdentifier)">
<summary>
 Returns all libraries for the given package and framework.
</summary>
</member>
<member name="M:Paket.Dependencies.GetInstalledVersion(Microsoft.FSharp.Core.FSharpOption{System.String},System.String)">
<summary>
 Returns the installed version of the given package.
</summary>
</member>
<member name="M:Paket.Dependencies.GetInstalledVersion(System.String)">
<summary>
 Returns the installed version of the given package.
</summary>
</member>
<member name="M:Paket.Dependencies.GetInstalledPackages(Paket.ReferencesFile)">
<summary>
 Returns the installed versions of all installed packages which are referenced in the references file.
</summary>
</member>
<member name="M:Paket.Dependencies.GetInstalledPackages">
<summary>
 Returns the installed versions of all installed packages.
</summary>
</member>
<member name="M:Paket.Dependencies.GetInstalledPackageModel(Microsoft.FSharp.Core.FSharpOption{System.String},System.String)">
<summary>
 Returns an InstallModel for the given package.
</summary>
</member>
<member name="M:Paket.Dependencies.GetGroups">
<summary>
 Returns all groups.
</summary>
</member>
<member name="M:Paket.Dependencies.GetDirectDependenciesForPackage(Paket.Domain.GroupName,System.String)">
<summary>
 Returns the direct dependencies for the given package.
</summary>
</member>
<member name="M:Paket.Dependencies.GetDirectDependencies">
<summary>
 Returns the installed versions of all direct dependencies.
</summary>
</member>
<member name="M:Paket.Dependencies.GetDirectDependencies(Paket.ReferencesFile)">
<summary>
 Returns the installed versions of all direct dependencies which are referenced in the references file.
</summary>
</member>
<member name="M:Paket.Dependencies.GetDependenciesFile">
<summary>
 Returns an instance of the paket.dependencies file.
</summary>
</member>
<member name="M:Paket.Dependencies.GetDefinedNuGetFeeds">
<summary>
 Returns all system-wide defined NuGet feeds. (Can be used for Autocompletion)
</summary>
</member>
<member name="M:Paket.Dependencies.FindReferencesFor(System.String,System.String)">
<summary>
 Finds all references files where the given package is referenced.
</summary>
</member>
<member name="M:Paket.Dependencies.FindReferencesFor(System.String)">
<summary>
 Finds all references files where the given main group package is referenced.
</summary>
</member>
<member name="M:Paket.Dependencies.FindProjectsFor(System.String,System.String)">
<summary>
 Finds all projects where the given package is referenced.
</summary>
</member>
<member name="M:Paket.Dependencies.FindOutdated(System.Boolean,System.Boolean)">
<summary>
 Finds all outdated packages.
</summary>
</member>
<member name="M:Paket.Dependencies.DownloadLatestBootstrapper(System.Boolean)">
<summary>
 Downloads the latest paket.bootstrapper into the .paket folder.
</summary>
</member>
<member name="M:Paket.Dependencies.DownloadLatestBootstrapper">
<summary>
 Downloads the latest paket.bootstrapper into the .paket folder.
</summary>
</member>
<member name="M:Paket.Dependencies.ConvertFromNuget(System.Boolean,System.Boolean,System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.String},System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.IO.DirectoryInfo})">
<summary>
 Converts the solution from NuGet to Paket.
</summary>
</member>
<member name="M:Paket.Dependencies.ConvertFromNuget(System.Boolean,System.Boolean,System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.IO.DirectoryInfo})">
<summary>
 Converts the solution from NuGet to Paket.
</summary>
</member>
<member name="M:Paket.Dependencies.ClearCache">
<summary>
 Clears the NuGet cache
</summary>
</member>
<member name="M:Paket.Dependencies.AddToken(System.String,System.String)">
<summary>
 Adds a token for a source
</summary>
</member>
<member name="M:Paket.Dependencies.AddToProject(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String,System.Boolean,Paket.SemVerUpdateMode,System.Boolean)">
<summary>
 Adds the given package with the given version to the dependencies file.
</summary>
</member>
<member name="M:Paket.Dependencies.AddCredentials(System.String,System.String,System.String)">
<summary>
 Adds credentials for a Nuget feed
</summary>
</member>
<member name="M:Paket.Dependencies.Add(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,Paket.SemVerUpdateMode,System.Boolean)">
<summary>
 Adds the given package with the given version to the dependencies file.
</summary>
</member>
<member name="M:Paket.Dependencies.Add(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,System.String)">
<summary>
 Adds the given package with the given version to the dependencies file.
</summary>
</member>
<member name="M:Paket.Dependencies.Add(System.String)">
<summary>
 Adds the given package without version requirements to main dependency group of the dependencies file.
</summary>
</member>
<member name="M:Paket.Dependencies.Add(Microsoft.FSharp.Core.FSharpOption{System.String},System.String)">
<summary>
 Adds the given package without version requirements to the dependencies file.
</summary>
</member>
<member name="T:Paket.Dependencies">
<summary>
 Paket API which is optimized for F# Interactive use.
</summary>
</member>
<member name="M:Paket.DependenciesFile.GetDependenciesInGroup(Paket.Domain.GroupName)">
<summary>
 Returns all direct NuGet dependencies in the given group.
</summary>
</member>
<member name="M:Paket.DependenciesFile.FindLockfile">
<summary>
 Find the matching lock file to a dependencies file
</summary>
</member>
<member name="M:Paket.DependenciesFile.FindLockfile(System.String)">
<summary>
 Find the matching lock file to a dependencies file
</summary>
</member>
<member name="T:Paket.DependenciesFile">
<summary>
 Allows to parse and analyze paket.dependencies files.
</summary>
</member>
<member name="T:Paket.DotNetCoreVersion">
<summary>
 The .NET Standard version.
</summary>
</member>
<member name="T:Paket.DotNetStandardVersion">
<summary>
 The .NET Standard version.
</summary>
</member>
<member name="T:Paket.FileItem">
<summary>
 File item inside of project files.
</summary>
</member>
<member name="T:Paket.FrameworkAssemblyReference">
<summary>
 Framework assembly reference inside of nuspec files.
</summary>
</member>
<member name="M:Paket.FrameworkIdentifier.IsSameCategoryAs(Paket.FrameworkIdentifier)">
<summary>
 Return if the parameter is of the same framework category (dotnet, windows phone, silverlight, ...)
</summary>
</member>
<member name="M:Paket.FrameworkIdentifier.IsCompatible(Paket.FrameworkIdentifier)">
<summary>
 TODO: some notion of an increasing/decreasing sequence of FrameworkIdentitifers, so that Between(bottom, top) constraints can enumerate the list
</summary>
</member>
<member name="T:Paket.FrameworkIdentifier">
<summary>
 Framework Identifier type.
</summary>
</member>
<member name="T:Paket.FrameworkVersion">
<summary>
 The Framework version.
</summary>
</member>
<member name="T:Paket.InstallModel">
<summary>
 Represents the contents of a particular package at a particular version.  Any install-specific actions like Content files, References, Roslyn Analyzers, MsBuild targets are represented here.
</summary>
</member>
<member name="T:Paket.InstallOptions">
<summary>
 [omit]
</summary>
</member>
<member name="T:Paket.InstallerOptions">
<summary>
 Force             - Force the download and reinstallation of all packages
 Redirects         - Create binding redirects for the NuGet packages
 OnlyReferenced    - Only install packages that are referenced in paket.references files.
 TouchAffectedRefs - Touch projects referencing installed packages even if the project file does not change.
</summary>
</member>
<member name="T:Paket.LibFolder">
<summary>
 Represents a subfolder of a nuget package that provides files (content, references, etc) for one or more Target Profiles.  This is a logical representation of the &apos;net45&apos; folder in a NuGet package, for example.
</summary>
</member>
<member name="M:Paket.LockFile.Save">
<summary>
 Updates the paket.lock file with the analyzed dependencies from the paket.dependencies file.
</summary>
</member>
<member name="M:Paket.LockFile.Parse(System.String,System.String[])">
<summary>
 Parses a paket.lock file from lines
</summary>
</member>
<member name="M:Paket.LockFile.LoadFrom(System.String)">
<summary>
 Parses a paket.lock file from file
</summary>
</member>
<member name="M:Paket.LockFile.GetAllNormalizedDependenciesOf(Paket.Domain.GroupName,Paket.Domain.PackageName,System.String)">
<summary>
 Gets all dependencies of the given package
</summary>
</member>
<member name="M:Paket.LockFile.GetAllDependenciesOfSafe(Paket.Domain.GroupName,Paket.Domain.PackageName)">
<summary>
 Gets all dependencies of the given package in the given group.
</summary>
</member>
<member name="M:Paket.LockFile.GetAllDependenciesOf(Paket.Domain.GroupName,Paket.Domain.PackageName,System.String)">
<summary>
 Gets all dependencies of the given package
</summary>
</member>
<member name="T:Paket.LockFile">
<summary>
 Allows to parse and analyze paket.lock files.
</summary>
</member>
<member name="M:Paket.Nuspec.Load(System.String)">
<summary>
 load the file from a given file.
</summary>
</member>
<member name="M:Paket.Nuspec.Load(System.String,System.String)">
<summary>
 load the file from an xml text. The fileName is only used for error reporting.
</summary>
</member>
<member name="M:Paket.Nuspec.Load(System.String,System.IO.Stream)">
<summary>
 load the file from an nuspec text stream. The fileName is only used for error reporting.
</summary>
</member>
<member name="M:Paket.Nuspec.Load(System.String,System.Xml.XmlDocument)">
<summary>
 load the file from an XmlDocument. The fileName is only used for error reporting.
</summary>
</member>
<member name="T:Paket.NuspecReferences">
<summary>
  Nuspec reference type inside of nuspec files.
</summary>
</member>
<member name="T:Paket.PreRelease">
<summary>
 Information about PreRelease packages.
</summary>
</member>
<member name="T:Paket.PreReleaseStatus">
<summary>
 Defines if the range accepts prereleases
</summary>
</member>
<member name="M:Paket.ProjectFile.FindAllProjects(System.String)">
<summary>
 Finds all project files
</summary>
</member>
<member name="T:Paket.ProjectFile">
<summary>
 Contains methods to read and manipulate project files.
</summary>
</member>
<member name="T:Paket.ProjectOutputType">
<summary>
 Project output type.
</summary>
</member>
<member name="T:Paket.ProjectReference">
<summary>
 Project references inside of project files.
</summary>
</member>
<member name="T:Paket.ResolverStrategy">
<summary>
 Represents a resolver strategy.
</summary>
</member>
<member name="P:Paket.SemVerInfo.Build">
<summary>
 The optional build no.
</summary>
</member>
<member name="P:Paket.SemVerInfo.PreRelease">
<summary>
 The optional PreRelease version
</summary>
</member>
<member name="P:Paket.SemVerInfo.Patch">
<summary>
 PATCH version when you make backwards-compatible bug fixes.
</summary>
</member>
<member name="P:Paket.SemVerInfo.Minor">
<summary>
 MINOR version when you add functionality in a backwards-compatible manner.
</summary>
</member>
<member name="P:Paket.SemVerInfo.Major">
<summary>
 MAJOR version when you make incompatible API changes.
</summary>
</member>
<member name="T:Paket.SemVerInfo">
<summary>
 Contains the version information.
</summary>
</member>
<member name="T:Paket.SolutionFile">
<summary>
 Contains methods to read and manipulate solution files.
</summary>
</member>
<member name="T:Paket.UAPVersion">
<summary>
 The UAP version.
</summary>
</member>
<member name="T:Paket.VersionRange">
<summary>
 Represents version information.
</summary>
</member>
<member name="T:Paket.VersionRangeBound">
<summary>
 Defines if the range bound is including or excluding.
</summary>
</member>
<member name="M:Paket.VersionRequirement.Parse(System.String)">
<summary>
 Parses NuGet V2 version range
</summary>
</member>
<member name="M:Paket.VersionRequirement.IsInRange(Paket.SemVerInfo,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Checks wether the given version is in the version range
</summary>
</member>
<member name="M:Paket.VersionRequirement.FormatInNuGetSyntax">
<summary>
 Formats a VersionRequirement in NuGet syntax
</summary>
</member>
<member name="T:Paket.AddProcess">
<summary>
 Contains methods for addition of new packages
</summary>
</member>
<member name="T:Paket.BindingRedirects.BindingRedirect">
<summary>
 Represents a binding redirection
</summary>
</member>
<member name="M:Paket.BindingRedirects.getPublicKeyToken(Mono.Cecil.AssemblyDefinition)">
<summary>
 Calculates the short form of the public key token for use with binding redirects, if it exists.
</summary>
</member>
<member name="M:Paket.BindingRedirects.applyBindingRedirectsToFolder``1(System.Boolean,System.Boolean,System.Boolean,System.String,System.Collections.Generic.IEnumerable{Paket.Reference},Microsoft.FSharp.Core.FSharpFunc{Paket.ProjectFile,``0})">
<summary>
 Applies a set of binding redirects to all .config files in a specific folder.
</summary>
</member>
<member name="M:Paket.BindingRedirects.applyBindingRedirects(System.Boolean,System.Boolean,System.Collections.Generic.IEnumerable{Paket.Reference},System.Collections.Generic.IEnumerable{Paket.BindingRedirects.BindingRedirect},System.String)">
<summary>
 Applies a set of binding redirects to a single configuration file.
</summary>
</member>
<member name="M:Paket.BindingRedirects.setRedirect(System.Xml.Linq.XDocument,Paket.BindingRedirects.BindingRedirect)">
<summary>
 Updates the supplied MSBuild document with the supplied binding redirect.
</summary>
</member>
<member name="M:Paket.ConfigFile.GetAuthentication(System.String)">
<summary>
 Get the authentication from the authentication store for a specific source
</summary>
</member>
<member name="P:Paket.ConfigFile.GetAuthenticationForUrl">
<summary>
 Get the authentication from the authentication store for a specific source and validates against the url
</summary>
</member>
<member name="M:Paket.ConfigFile.checkCredentials(System.String,Microsoft.FSharp.Core.FSharpOption{Paket.Utils.Auth})">
<summary>
 Check if the provided credentials for a specific source are correct
</summary>
</member>
<member name="M:Paket.ConfigFile.Decrypt(System.String,System.String)">
<summary>
 Decrypt a encrypted string with a user specific keys
</summary>
</member>
<member name="M:Paket.ConfigFile.Encrypt(System.String)">
<summary>
 Encrypts a string with a user specific keys
</summary>
</member>
<member name="P:Paket.Constants.NuGetCacheFolder">
<summary>
 The NuGet cache folder.
</summary>
</member>
<member name="P:Paket.Constants.MagicUnlistingDate">
<summary>
 The magic unpublished date is 1900-01-01T00:00:00
</summary>
</member>
<member name="T:Paket.DependenciesFileSerializer">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.DependencyModel.CalcDependencies(Paket.DependenciesFile,Paket.Domain.GroupName,System.String)">
<summary>
 Calculates the used dependencies for a project.
</summary>
</member>
<member name="M:Paket.DependencyModel.CalcDependenciesForReferencesFile(Paket.DependenciesFile,Paket.Domain.GroupName,System.String)">
<summary>
 Calculates the used dependencies for given references file.
</summary>
</member>
<member name="M:Paket.DependencyModel.CalcDependenciesForDirectPackages(Paket.DependenciesFile,Paket.Domain.GroupName,Microsoft.FSharp.Collections.FSharpList{Paket.Domain.PackageName})">
<summary>
 Calculates the used dependencies for the given direct references.
</summary>
</member>
<member name="T:Paket.Domain.GroupName">
<summary>
 Represents a normalized group name
</summary>
</member>
<member name="T:Paket.Domain.PackageName">
<summary>
 Represents a NuGet package name
</summary>
</member>
<member name="M:Paket.Domain.GroupName(System.String)">
<summary>
 Function to convert a string into a group name
</summary>
</member>
<member name="M:Paket.Domain.PackageName(System.String)">
<summary>
 Function to convert a string into a NuGet package name
</summary>
</member>
<member name="M:Paket.FindOutdated.ShowOutdated(System.Boolean,System.Boolean,Paket.PaketEnv)">
<summary>
 Prints all outdated packages.
</summary>
</member>
<member name="M:Paket.FindOutdated.FindOutdated(System.Boolean,System.Boolean,Paket.PaketEnv)">
<summary>
 Finds all outdated packages.
</summary>
</member>
<member name="T:Paket.FindOutdated">
<summary>
 Contains methods to find outdated packages.
</summary>
</member>
<member name="M:Paket.GarbageCollection.CleanUp(System.String,Paket.DependenciesFile,Paket.LockFile)">
<summary>
 Remove all packages from the packages folder which are not part of the lock file.
</summary>
</member>
<member name="M:Paket.GarbageCollection.removeOlderVersionsFromCache(Paket.Cache,Paket.Domain.PackageName,System.Collections.Generic.IEnumerable{Paket.SemVerInfo})">
<summary>
 Removes older packages from the cache
</summary>
</member>
<member name="M:Paket.GarbageCollection.deleteUnusedPackages(System.String,Paket.LockFile)">
<summary>
 Remove all packages from the packages folder which are not part of the lock file.
</summary>
</member>
<member name="M:Paket.GarbageCollection.discoverExtractedPackages(System.String)">
<summary>
 Discover all packages currently available in the packages folder
</summary>
</member>
<member name="T:Paket.GarbageCollection">
<summary>
 Contains methods for the garbage collection of no longer needed files.
</summary>
</member>
<member name="T:Paket.Git.CommandHelper.ProcessResult">
<summary>
 A process result including error code, message log and errors.
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.runSimpleGitCommand(System.String,System.String)">
<summary>
 Runs the git command and returns the first line of the result.
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.runFullGitCommand(System.String,System.String)">
<summary>
 Runs the git command and returns the results.
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.gitCommandf``1(System.String,Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Core.Unit})">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.gitCommand(System.String,System.String)">
<summary>
 Runs the given git command, waits for its completion.
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.directRunGitCommand(System.String,System.String)">
<summary>
 Runs the given git command, waits for its completion and returns whether it succeeded.
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.directExec(Microsoft.FSharp.Core.FSharpFunc{System.Diagnostics.ProcessStartInfo,Microsoft.FSharp.Core.Unit})">
<summary>
 Runs the given process, waits for its completion and returns if it succeeded.
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.fireAndForgetGitCommand(System.String,System.String)">
<summary>
 Fires the given git command ind the given repository directory and returns immediatly.
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.fireAndForget(Microsoft.FSharp.Core.FSharpFunc{System.Diagnostics.ProcessStartInfo,Microsoft.FSharp.Core.Unit})">
<summary>
 Starts the given process and returns immediatly.
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.getGitResult(System.String,System.String)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.runGitCommandf``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Core.FSharpFunc{System.String,System.Tuple{System.Boolean,System.Collections.Generic.List{System.String},System.String}}})">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.runGitCommand(System.String,System.String)">
<summary>
 Runs git.exe with the given command in the given repository directory.
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.toLines(System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Converts a sequence of strings into a string separated with line ends
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.separated(System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Converts a sequence of strings to a string with delimiters
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.ExecProcessAndReturnMessages(Microsoft.FSharp.Core.FSharpFunc{System.Diagnostics.ProcessStartInfo,Microsoft.FSharp.Core.Unit},System.TimeSpan)">
<summary>
 Runs the given process and returns the process result.
 ## Parameters

  - `configProcessStartInfoF` - A function which overwrites the default ProcessStartInfo.
  - `timeOut` - The timeout for the process.
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.ExecProcessWithLambdas(Microsoft.FSharp.Core.FSharpFunc{System.Diagnostics.ProcessStartInfo,Microsoft.FSharp.Core.Unit},System.TimeSpan,System.Boolean,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit})">
<summary>
 Runs the given process and returns the exit code.
 ## Parameters

  - `configProcessStartInfoF` - A function which overwrites the default ProcessStartInfo.
  - `timeOut` - The timeout for the process.
  - `silent` - If this flag is set then the process output is redirected to the given output functions `errorF` and `messageF`.
  - `errorF` - A function which will be called with the error log.
  - `messageF` - A function which will be called with the message log.
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.start(System.Diagnostics.Process)">
<summary>
 [omit]
</summary>
</member>
<member name="P:Paket.Git.CommandHelper.startedProcesses">
<summary>
 [omit]
</summary>
</member>
<member name="P:Paket.Git.CommandHelper.gitPath">
<summary>
 Tries to locate the git.exe via the eviroment variable &quot;GIT&quot;.
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.findPath(System.String,System.String,System.String)">
<summary>
 Tries to find the tool via AppSettings. If no path has the right tool we are trying the PATH system variable.
 [omit]
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.tryFindPath(System.String,System.String,System.String)">
<summary>
 Tries to find the tool via AppSettings. If no path has the right tool we are trying the PATH system variable.
 [omit]
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.appSettings(System.String,System.String)">
<summary>
 Returns the AppSettings for the key - Splitted on ;
 [omit]
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.tryFindFileOnPath(System.String)">
<summary>
 Searches the current directory and the directories within the PATH
 environment variable for the given file. If successful returns the full
 path to the file.
 ## Parameters
  - `file` - The file to locate
</summary>
</member>
<member name="P:Paket.Git.CommandHelper.pathDirectories">
<summary>
 Gets the list of valid directories included in the PATH environment variable.
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.isValidPath(System.String)">
<summary>
 Detects whether the given path does not contains invalid characters.
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.splitEnvironVar(System.String)">
<summary>
 Splits the entries of an environment variable and removes the empty ones.
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.environVarOrNone(System.String)">
<summary>
 Retrieves the environment variable or None
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.findFile(System.Collections.Generic.IEnumerable{System.String},System.String)">
<summary>
 Searches the given directories for the given file, failing if not found.
 [omit]
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.tryFindFile(System.Collections.Generic.IEnumerable{System.String},System.String)">
<summary>
 Searches the given directories for all occurrences of the given file name
 [omit]
</summary>
</member>
<member name="P:Paket.Git.CommandHelper.gitTimeOut">
<summary>
 Specifies a global timeout for git.exe - default is *no timeout*
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.platformInfoAction(System.Diagnostics.ProcessStartInfo)">
<summary>
 Modifies the ProcessStartInfo according to the platform semantics
</summary>
</member>
<member name="P:Paket.Git.CommandHelper.monoArguments">
<summary>
 Arguments on the Mono executable
</summary>
</member>
<member name="T:Paket.Git.CommandHelper">
<summary>
 Contains helpers which allow to interact with [git](http://git-scm.com/) via the command line.
</summary>
</member>
<member name="M:Paket.InstallProcess.Install``1(Paket.InstallerOptions,System.Boolean,Paket.DependenciesFile,Paket.LockFile,Microsoft.FSharp.Collections.FSharpMap{Paket.Domain.GroupName,``0})">
<summary>
 Installs all packages from the lock file.
</summary>
</member>
<member name="M:Paket.InstallProcess.InstallIntoProjects``1(Paket.InstallerOptions,System.Boolean,Paket.DependenciesFile,Paket.LockFile,Microsoft.FSharp.Collections.FSharpList{System.Tuple{Paket.ProjectFile,Paket.ReferencesFile}},Microsoft.FSharp.Collections.FSharpMap{Paket.Domain.GroupName,``0})">
<summary>
 Installs all packages from the lock file.
</summary>
</member>
<member name="M:Paket.InstallProcess.applyBindingRedirects``1(System.Boolean,System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.Boolean},System.Boolean,System.String,Paket.Domain.GroupName,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Paket.Domain.GroupName,Paket.Domain.PackageName,System.String},``0},System.Collections.Generic.IEnumerable{Paket.Reference},System.Collections.Generic.Dictionary{System.String,Microsoft.FSharp.Core.FSharpOption{Paket.ProjectFile}},System.Collections.Generic.IEnumerable{System.Tuple{Paket.InstallModel,Microsoft.FSharp.Core.FSharpOption{Paket.Requirements.BindingRedirectsSettings}}})">
<summary>
 Applies binding redirects for all strong-named references to all app. and web.config files.
</summary>
</member>
<member name="M:Paket.InstallProcess.CreateModel``1(System.String,System.Boolean,Paket.DependenciesFile,Paket.LockFile,Microsoft.FSharp.Collections.FSharpSet{System.Tuple{Paket.Domain.GroupName,Paket.Domain.PackageName}},Microsoft.FSharp.Collections.FSharpMap{Paket.Domain.GroupName,``0})">
<summary>
 Restores the given packages from the lock file.
</summary>
</member>
<member name="T:Paket.InstallProcess">
<summary>
 Contains methods for the install process.
</summary>
</member>
<member name="M:Paket.LanguageEvaluation.getProjectLanguage(System.Xml.XmlDocument,System.String)">
<summary>
 Get the programming language for a project file using the &quot;ProjectTypeGuids&quot;
</summary>
</member>
<member name="M:Paket.LoadingScripts.ScriptGeneration.generateScriptsForRootFolderGeneric(System.String,Microsoft.FSharp.Core.FSharpFunc{Paket.LoadingScripts.ScriptGeneration.ScriptGenInput,Paket.LoadingScripts.ScriptGeneration.ScriptGenResult},Microsoft.FSharp.Core.FSharpFunc{System.IO.FileInfo,Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{Paket.LoadingScripts.ScriptGeneration.ScriptPiece},Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String}},Microsoft.FSharp.Core.FSharpFunc{System.String,System.Boolean},Paket.FrameworkIdentifier,System.IO.DirectoryInfo)">
<summary>
 Generate a include scripts for all packages defined in paket.dependencies,
 if a package is ordered before its dependencies this function will throw.
</summary>
</member>
<member name="M:Paket.LoadingScripts.ScriptGeneration.generateScripts(Microsoft.FSharp.Core.FSharpFunc{Paket.LoadingScripts.ScriptGeneration.ScriptGenInput,Paket.LoadingScripts.ScriptGeneration.ScriptGenResult},Microsoft.FSharp.Core.FSharpFunc{System.IO.FileInfo,Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{Paket.LoadingScripts.ScriptGeneration.ScriptPiece},Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpFunc{Paket.Domain.GroupName,Microsoft.FSharp.Core.FSharpFunc{Paket.Domain.PackageName,System.IO.FileInfo}},System.IO.DirectoryInfo,Paket.FrameworkIdentifier,Paket.Dependencies,System.IO.DirectoryInfo,Paket.Domain.GroupName,Microsoft.FSharp.Collections.FSharpList{Paket.PackageResolver.ResolvedPackage})">
<summary>
 Generate a include script from given order of packages,
 if a package is ordered before its dependencies this function 
 will throw.
</summary>
</member>
<member name="M:Paket.LoadingScripts.ScriptGeneration.generateCSharpScript(Paket.LoadingScripts.ScriptGeneration.ScriptGenInput)">
<summary>
 default implementation of C# include script generator
</summary>
</member>
<member name="M:Paket.LoadingScripts.ScriptGeneration.generateFSharpScript(Paket.LoadingScripts.ScriptGeneration.ScriptGenInput)">
<summary>
 default implementation of F# include script generator
</summary>
</member>
<member name="M:Paket.LockFileSerializer.serializePackages(Paket.InstallOptions,Microsoft.FSharp.Collections.FSharpMap{Paket.Domain.PackageName,Paket.PackageResolver.ResolvedPackage})">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.LockFileSerializer.serializeOptionsAsLines(Paket.InstallOptions)">
<summary>
 [omit]
</summary>
</member>
<member name="T:Paket.ModuleResolver">
<summary>
 Contains logic which helps to resolve the dependency graph for modules
</summary>
</member>
<member name="T:Paket.NuGet">
<summary>
 Contains NuGet support.
</summary>
</member>
<member name="T:Paket.NuGetConvert.NugetPackagesConfig">
<summary>
 Represents NuGet packages.config file
</summary>
</member>
<member name="T:Paket.NuGetConvert.NugetPackagesConfigType">
<summary>
 Represents type of NuGet packages.config file
</summary>
</member>
<member name="T:Paket.NuGetConvert">
<summary>
 Contains methods for NuGet conversion
</summary>
</member>
<member name="M:Paket.NuGetV2.DownloadPackage(System.String,Paket.PackageSources.PackageSource,Microsoft.FSharp.Collections.FSharpList{Paket.Cache},Paket.Domain.GroupName,Paket.Domain.PackageName,Paket.SemVerInfo,System.Boolean,System.Boolean,System.Boolean)">
<summary>
 Downloads the given package to the NuGet Cache folder
</summary>
</member>
<member name="M:Paket.NuGetV2.GetVersions(System.Boolean,System.String,System.Collections.Generic.IEnumerable{Paket.PackageSources.PackageSource},Paket.Domain.PackageName)">
<summary>
 Allows to retrieve all version no. for a package from the given sources.
</summary>
</member>
<member name="M:Paket.NuGetV2.FindPackages``1(Microsoft.FSharp.Core.FSharpOption{Paket.PackageSources.NugetSourceAuthentication},System.String,System.String,``0)">
<summary>
 Uses the NuGet v2 API to retrieve all packages with the given prefix.
</summary>
</member>
<member name="M:Paket.NuGetV2.GetAnalyzerFiles(System.String)">
<summary>
 Finds all analyzer files in a nuget package.
</summary>
</member>
<member name="M:Paket.NuGetV2.GetTargetsFiles(System.String)">
<summary>
 Finds all targets files in a nuget package.
</summary>
</member>
<member name="M:Paket.NuGetV2.GetLibFiles(System.String)">
<summary>
 Finds all libraries in a nuget package.
</summary>
</member>
<member name="M:Paket.NuGetV2.CopyToCache(Paket.Cache,System.String,System.Boolean)">
<summary>
 Puts the package into the cache
</summary>
</member>
<member name="M:Paket.NuGetV2.CopyFromCache(System.String,Paket.Domain.GroupName,System.String,System.String,Paket.Domain.PackageName,Paket.SemVerInfo,System.Boolean,System.Boolean,System.Boolean)">
<summary>
 Extracts the given package to the ./packages folder
</summary>
</member>
<member name="M:Paket.NuGetV2.ExtractPackage(System.String,System.String,Paket.Domain.PackageName,Paket.SemVerInfo,System.Boolean)">
<summary>
 Extracts the given package to the ./packages folder
</summary>
</member>
<member name="M:Paket.NuGetV2.ExtractPackageToUserFolder``1(System.String,Paket.Domain.PackageName,Paket.SemVerInfo,``0)">
<summary>
 Extracts the given package to the user folder
</summary>
</member>
<member name="M:Paket.NuGetV2.getDetailsFromLocalNuGetPackage(System.Boolean,System.String,System.String,Paket.Domain.PackageName,Paket.SemVerInfo)">
<summary>
 Reads direct dependencies from a nupkg file
</summary>
</member>
<member name="M:Paket.NuGetV2.getPackageNameFromLocalFile(System.String)">
<summary>
 Reads package name from a nupkg file
</summary>
</member>
<member name="M:Paket.NuGetV2.getDetailsFromNuGetViaOData(Microsoft.FSharp.Core.FSharpOption{Paket.Utils.Auth},System.String,Paket.Domain.PackageName,Paket.SemVerInfo)">
<summary>
 Gets package details from NuGet via OData
</summary>
</member>
<member name="M:Paket.NuGetV2.getAllVersionsFromLocalPath(System.Boolean,System.String,Paket.Domain.PackageName,System.String)">
<summary>
 Gets versions of the given package from local NuGet feed.
</summary>
</member>
<member name="T:Paket.NuGetV2">
<summary>
 Contains NuGet support.
</summary>
</member>
<member name="T:Paket.NuGetV3.JSONRootData">
<summary>
 [omit]
</summary>
</member>
<member name="T:Paket.NuGetV3.JSONVersionData">
<summary>
 [omit]
</summary>
</member>
<member name="T:Paket.NuGetV3.JSONResource">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.NuGetV3.GetPackageDetails(System.Boolean,Paket.PackageSources.NugetV3Source,Paket.Domain.PackageName,Paket.SemVerInfo)">
<summary>
 Uses the NuGet v3 registration endpoint to retrieve package details .
</summary>
</member>
<member name="M:Paket.NuGetV3.FindPackages(Microsoft.FSharp.Core.FSharpOption{Paket.PackageSources.NugetSourceAuthentication},System.String,System.String,System.Int32)">
<summary>
 Uses the NuGet v3 autocomplete service to retrieve all packages with the given prefix.
</summary>
</member>
<member name="M:Paket.NuGetV3.extractPackages(System.String)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.NuGetV3.FindVersionsForPackage(System.String,Microsoft.FSharp.Core.FSharpOption{Paket.Utils.Auth},Paket.Domain.PackageName)">
<summary>
 Uses the NuGet v3 service to retrieve all package versions for the given package.
</summary>
</member>
<member name="M:Paket.NuGetV3.FindAutoCompleteVersionsForPackage(System.String,Microsoft.FSharp.Core.FSharpOption{Paket.Utils.Auth},Paket.Domain.PackageName,System.Boolean,System.Int32)">
<summary>
 Uses the NuGet v3 autocomplete service to retrieve all package versions for the given package.
</summary>
</member>
<member name="M:Paket.NuGetV3.extractVersions(System.String)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.NuGetV3.extractAutoCompleteVersions(System.String)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.NuGetV3.getAllVersionsAPI(Microsoft.FSharp.Core.FSharpOption{Paket.PackageSources.NugetSourceAuthentication},System.String)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.NuGetV3.getSearchAPI(Microsoft.FSharp.Core.FSharpOption{Paket.PackageSources.NugetSourceAuthentication},System.String)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.NuGetV3.calculateNuGet2Path(System.String)">
<summary>
 Calculates the NuGet v3 URL from a NuGet v2 URL.
</summary>
</member>
<member name="M:Paket.NuGetV3.calculateNuGet3Path(System.String)">
<summary>
 Calculates the NuGet v3 URL from a NuGet v2 URL.
</summary>
</member>
<member name="P:Paket.NuGetV3.allVersionsDict">
<summary>
 [omit]
</summary>
</member>
<member name="P:Paket.NuGetV3.searchDict">
<summary>
 [omit]
</summary>
</member>
<member name="T:Paket.NuGetV3">
<summary>
 Contains NuGet support.
</summary>
</member>
<member name="T:Paket.PackageResolver.ResolvedPackage">
<summary>
 Represents data about resolved packages
</summary>
</member>
<member name="T:Paket.PackageResolver.PackageDetails">
<summary>
 Represents package details
</summary>
</member>
<member name="M:Paket.PackageResolver.Resolve(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Paket.PackageSources.PackageSource},Microsoft.FSharp.Core.FSharpFunc{Paket.ResolverStrategy,Microsoft.FSharp.Core.FSharpFunc{Paket.Domain.GroupName,Microsoft.FSharp.Core.FSharpFunc{Paket.Domain.PackageName,System.Collections.Generic.IEnumerable{System.Tuple{Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList{Paket.PackageSources.PackageSource}}}}}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Paket.PackageSources.PackageSource},Microsoft.FSharp.Core.FSharpFunc{Paket.Domain.GroupName,Microsoft.FSharp.Core.FSharpFunc{Paket.Domain.PackageName,Microsoft.FSharp.Core.FSharpFunc{Paket.SemVerInfo,Paket.PackageResolver.PackageDetails}}}},Paket.Domain.GroupName,Microsoft.FSharp.Core.FSharpOption{Paket.ResolverStrategy},Microsoft.FSharp.Core.FSharpOption{Paket.ResolverStrategy},Paket.Requirements.FrameworkRestrictions,Microsoft.FSharp.Collections.FSharpSet{Paket.Requirements.PackageRequirement},Paket.PackageResolver.UpdateMode)">
<summary>
 Resolves all direct and transitive dependencies
</summary>
</member>
<member name="T:Paket.PackageResolver">
<summary>
 Contains logic which helps to resolve the dependency graph.
</summary>
</member>
<member name="T:Paket.PackageSources.PackageSource">
<summary>
 Represents the package source type.
</summary>
</member>
<member name="M:Paket.ProjectFileModule.appendMap``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Append two maps with the properties of the second replacing properties of the first
</summary>
</member>
<member name="M:Paket.PublicAPI.ParseSemVer(System.String)">
<summary>
 Takes a version string formatted for Semantic Versioning and parses it
 into the internal representation used by Paket.
</summary>
</member>
<member name="M:Paket.Releases.downloadLatestBootstrapperAndTargets(System.Boolean,Paket.PaketEnv)">
<summary>
 Downloads the latest version of the paket.bootstrapper and paket.targets to the .paket dir
</summary>
</member>
<member name="M:Paket.Releases.downloadLatestVersionOf(Microsoft.FSharp.Collections.FSharpList{System.String},System.String)">
<summary>
 Downloads the latest version of the given files to the destination dir
</summary>
</member>
<member name="M:Paket.RemoteDownload.downloadRemoteFiles(Paket.ModuleResolver.ResolvedSourceFile,System.String)">
<summary>
 Retrieves RemoteFiles
</summary>
</member>
<member name="M:Paket.RemoteDownload.downloadDependenciesFile``1(System.Boolean,System.String,Paket.Domain.GroupName,Microsoft.FSharp.Core.FSharpFunc{System.String,``0},Paket.ModuleResolver.ResolvedSourceFile)">
<summary>
 Gets a dependencies file from the remote source and tries to parse it.
</summary>
</member>
<member name="M:Paket.RemoveProcess.Remove(System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Paket.Domain.PackageName,System.Boolean,System.Boolean,System.Boolean)">
<summary>
 Remove a package with the option to interactively remove it from multiple projects.
</summary>
</member>
<member name="M:Paket.RemoveProcess.RemoveFromProject(System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Paket.Domain.PackageName,System.Boolean,System.String,System.Boolean)">
<summary>
 Removes a package with the option to remove it from a specified project.
</summary>
</member>
<member name="T:Paket.RemoveProcess">
<summary>
 Contains methods to remove installed packages
</summary>
</member>
<member name="T:Paket.Requirements.PackageRequirement">
<summary>
 Represents an unresolved package.
</summary>
</member>
<member name="M:Paket.Requirements.FrameworkRestriction.IsSameCategoryAs(Paket.Requirements.FrameworkRestriction)">
<summary>
 Return if the parameter is a restriction of the same framework category (dotnet, windows phone, silverlight, ...)
</summary>
</member>
<member name="M:Paket.Requirements.applyRestrictionsToTargets(Microsoft.FSharp.Collections.FSharpList{Paket.Requirements.FrameworkRestriction},Microsoft.FSharp.Collections.FSharpList{Paket.TargetProfile})">
<summary>
 Get all targets that should be considered with the specified restrictions
</summary>
</member>
<member name="P:Paket.Requirements.isTargetMatchingRestrictions">
<summary>
 Get if a target should be considered with the specified restrictions
</summary>
</member>
<member name="M:Paket.RestoreProcess.restore(System.String,Paket.Domain.GroupName,Microsoft.FSharp.Collections.FSharpList{Paket.PackageSources.PackageSource},Microsoft.FSharp.Collections.FSharpList{Paket.Cache},System.Boolean,Paket.LockFile,Microsoft.FSharp.Collections.FSharpSet{Paket.Domain.PackageName},Microsoft.FSharp.Collections.FSharpSet{Paket.Domain.PackageName})">
<summary>
 Restores the given dependencies from the lock file.
</summary>
</member>
<member name="M:Paket.RestoreProcess.ExtractPackage(System.String,Paket.Domain.GroupName,Microsoft.FSharp.Collections.FSharpList{Paket.PackageSources.PackageSource},Microsoft.FSharp.Collections.FSharpList{Paket.Cache},System.Boolean,Paket.PackageResolver.ResolvedPackage,System.Boolean)">
<summary>
 Downloads and extracts a package.
</summary>
</member>
<member name="T:Paket.RestoreProcess">
<summary>
 Contains methods for the restore process.
</summary>
</member>
<member name="P:Paket.SemVer.Parse">
<summary>
 Parses the given version string into a SemVerInfo which can be printed using ToString() or compared
 according to the rules described in the [SemVer docs](http://semver.org/).
 ## Sample

     parse &quot;1.0.0-rc.1&quot;     &lt; parse &quot;1.0.0&quot;          // true
     parse &quot;1.2.3-alpha&quot;    &gt; parse &quot;1.2.2&quot;          // true
     parse &quot;1.2.3-alpha2&quot;   &gt; parse &quot;1.2.3-alpha&quot;    // true
     parse &quot;1.2.3-alpha002&quot; &gt; parse &quot;1.2.3-alpha1&quot;   // true
     parse &quot;1.5.0-beta.2&quot;   &gt; parse &quot;1.5.0-rc.1&quot;     // false
</summary>
</member>
<member name="T:Paket.SemVer">
<summary>
  Parser which allows to deal with [Semantic Versioning](http://semver.org/) (SemVer).
</summary>
</member>
<member name="M:Paket.UpdateProcess.Update(System.String,Paket.UpdaterOptions)">
<summary>
 Update command
</summary>
</member>
<member name="M:Paket.UpdateProcess.UpdateGroup(System.String,Paket.Domain.GroupName,Paket.UpdaterOptions)">
<summary>
 Update a single group command
</summary>
</member>
<member name="M:Paket.UpdateProcess.UpdateFilteredPackages(System.String,Paket.Domain.GroupName,System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Paket.UpdaterOptions)">
<summary>
 Update a filtered list of packages
</summary>
</member>
<member name="M:Paket.UpdateProcess.UpdatePackage(System.String,Paket.Domain.GroupName,Paket.Domain.PackageName,Microsoft.FSharp.Core.FSharpOption{System.String},Paket.UpdaterOptions)">
<summary>
 Update a single package command
</summary>
</member>
<member name="M:Paket.UpdateProcess.SmartInstall(Paket.DependenciesFile,Paket.PackageResolver.UpdateMode,Paket.UpdaterOptions)">
<summary>
 Smart install command
</summary>
</member>
<member name="T:Paket.UpdateProcess">
<summary>
 Contains methods for the update process.
</summary>
</member>
<member name="M:Paket.Utils.FindAllFiles(System.String,System.String)">
<summary>
 Gets all files with the given pattern
</summary>
</member>
<member name="M:Paket.Utils.askYesNo(System.String)">
<summary>
 If the guard is true then a [Y]es / [N]o question will be ask.
 Until the user pressed y or n.
</summary>
</member>
<member name="M:Paket.Utils.safeGetFromUrl(Microsoft.FSharp.Core.FSharpOption{Paket.Utils.Auth},System.String,System.String)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Utils.getFromUrl(Microsoft.FSharp.Core.FSharpOption{Paket.Utils.Auth},System.String,System.String)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Utils.downloadFromUrl(Microsoft.FSharp.Core.FSharpOption{Paket.Utils.Auth},System.String,System.String)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Utils.normalizeXml(System.Xml.XmlDocument)">
<summary>
 [omit]
</summary>
</member>
<member name="P:Paket.Utils.isMono">
<summary>
 Determines if the current system is a mono system
 Todo: Detect mono on windows
</summary>
</member>
<member name="P:Paket.Utils.isWindows">
<summary>
 Determines if the current system is a Windows system
</summary>
</member>
<member name="P:Paket.Utils.isLinux">
<summary>
 Determines if the current system is a Linux system
</summary>
</member>
<member name="P:Paket.Utils.isMacOS">
<summary>
 Determines if the current system is a MacOs system
</summary>
</member>
<member name="P:Paket.Utils.isUnix">
<summary>
 Determines if the current system is an Unix system
</summary>
</member>
<member name="P:Paket.Utils.SystemRoot">
<summary>
 The system root environment variable. Typically &quot;C:\Windows&quot;
</summary>
</member>
<member name="P:Paket.Utils.ProgramFilesX86">
<summary>
 The path of Program Files (x86)
 It seems this covers all cases where PROCESSOR\_ARCHITECTURE may misreport and the case where the other variable 
 PROCESSOR\_ARCHITEW6432 can be null
</summary>
</member>
<member name="P:Paket.Utils.ProgramFiles">
<summary>
 The path of the &quot;Program Files&quot; folder - might be x64 on x64 machine
</summary>
</member>
<member name="M:Paket.Utils.createRelativePath(System.String,System.String)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Utils.CleanDir(System.String)">
<summary>
 Cleans a directory by deleting it and recreating it.
</summary>
</member>
<member name="M:Paket.Utils.createDir(System.String)">
<summary>
 Creates a directory if it does not exist.
</summary>
</member>
<member name="M:Paket.Utils.ObservableExtensions.Observable.guard``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit},System.IObservable{``0})">
<summary>
 Creates an observable that calls the specified function after someone
 subscribes to it (useful for waiting using &apos;let!&apos; when we need to start
 operation after &apos;let!&apos; attaches handler)
</summary>
</member>
<member name="T:Paket.Utils">
<summary>
 Contains methods for IO.
</summary>
</member>
<member name="M:Paket.VSIntegration.TurnOnAutoRestore(System.Boolean,Paket.PaketEnv)">
<summary>
 Activates the Visual Studio NuGet autorestore feature in all projects
</summary>
</member>
<member name="M:Paket.VSIntegration.TurnOffAutoRestore(Paket.PaketEnv)">
<summary>
 Deactivates the Visual Studio NuGet autorestore feature in all projects
</summary>
</member>
<member name="M:Paket.Xml.getChildNodes(System.Xml.XmlNode)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Xml.getDescendants(System.String,System.Xml.XmlNode)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Xml.getNodes(System.String,System.Xml.XmlNode)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Xml.optGetNode``1(System.String,Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Xml.getNode(System.String,System.Xml.XmlNode)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Xml.optGetAttribute``1(System.String,Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Xml.withAttributeValueEndsWith(System.String,System.String,System.Xml.XmlNode)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Xml.withAttributeValue(System.String,System.String,System.Xml.XmlNode)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Xml.getAttribute(System.String,System.Xml.XmlNode)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Xml.hasAttribute(System.String,System.Xml.XmlNode)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Xml.addChild(System.Xml.XmlNode,System.Xml.XmlElement)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Xml.addAttribute(System.String,System.String,System.Xml.XmlElement)">
<summary>
 [omit]
</summary>
</member>
<member name="T:ProviderImplementation.AssemblyReader.ILCallingConvStatics">
<summary>
 Static storage to amortize the allocation of ILCallingConv.Instance and ILCallingConv.Static
</summary>
</member>
<member name="T:ProviderImplementation.AssemblyReader.ILArgConvention">
<summary>
 Calling conventions.  These are used in method pointer types.
</summary>
</member>
</members>
</doc>
